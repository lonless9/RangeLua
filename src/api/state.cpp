/**
 * @file state.cpp
 * @brief Enhanced State implementation with comprehensive API support
 * @version 0.1.0
 */

#include <rangelua/api/state.hpp>
#include <rangelua/backend/bytecode.hpp>
#include <rangelua/backend/codegen.hpp>
#include <rangelua/core/error.hpp>
#include <rangelua/frontend/lexer.hpp>
#include <rangelua/frontend/parser.hpp>
#include <rangelua/stdlib/basic.hpp>
#include <rangelua/utils/logger.hpp>

#include <fstream>

namespace rangelua::api {

    // Initialize static logger
    namespace {
        auto& logger() {
            static auto log = utils::Logger::create_logger("api");
            return log;
        }
    }  // namespace

    State::State() : vm_() {
        logger()->info("Initializing RangeLua state");

        // Initialize global environment
        initialize_globals();

        logger()->debug("State initialization complete");
    }

    State::State(const StateConfig& config) : vm_(config.vm_config), config_(config) {
        logger()->info("Initializing RangeLua state with custom configuration");

        // Initialize global environment
        initialize_globals();

        logger()->debug("State initialization complete with config");
    }

    Result<std::vector<runtime::Value>> State::execute(StringView code, String name) {
        logger()->debug("Executing code: {} ({})", name, code.size());

        try {
            // Lexical analysis
            frontend::Lexer lexer(code, std::move(name));

            // Syntax analysis
            frontend::Parser parser(lexer);
            auto ast_result = parser.parse();
            if (std::holds_alternative<ErrorCode>(ast_result)) {
                auto error = std::get<ErrorCode>(ast_result);
                logger()->error("Parse error: {}", error_code_to_string(error));
                return error;
            }

            // Code generation
            backend::BytecodeEmitter emitter;
            backend::CodeGenerator codegen(emitter);
            auto codegen_result = codegen.generate(*std::get<frontend::ProgramPtr>(ast_result));
            if (std::holds_alternative<ErrorCode>(codegen_result)) {
                auto error = std::get<ErrorCode>(codegen_result);
                logger()->error("Codegen error: {}", error_code_to_string(error));
                return error;
            }

            // Get generated bytecode
            auto function = emitter.get_function();

            // Disassemble the function for debugging
            logger()->debug("Generated bytecode:\n{}",
                            backend::Disassembler::disassemble_function(function));

            // Execute
            logger()->debug("Executing bytecode function: {}", function.name);
            auto result = vm_.execute(function);

            if (is_success(result)) {
                logger()->debug("Execution completed successfully");
            } else {
                logger()->error("Execution failed: {}", error_code_to_string(get_error(result)));
            }

            return result;

        } catch (const Exception& e) {
            logger()->error("Exception during execution: {}", e.what());
            return e.code();
        } catch (const std::exception& e) {
            logger()->error("Standard exception during execution: {}", e.what());
            return ErrorCode::RUNTIME_ERROR;
        } catch (...) {
            logger()->error("Unknown exception during execution");
            return ErrorCode::UNKNOWN_ERROR;
        }
    }

    Result<std::vector<runtime::Value>> State::execute_file(const String& filename) {
        logger()->info("Executing file: {}", filename);

        std::ifstream file(filename);
        if (!file.is_open()) {
            logger()->error("Failed to open file: {}", filename);
            return ErrorCode::IO_ERROR;
        }

        std::string content((std::istreambuf_iterator<char>(file)),
                            std::istreambuf_iterator<char>());

        logger()->debug("File loaded, size: {} bytes", content.size());
        return execute(content, filename);
    }

    Size State::stack_size() const noexcept {
        return vm_.stack_size();
    }

    void State::push(runtime::Value value) {
        vm_.push(std::move(value));
    }

    runtime::Value State::pop() {
        return vm_.pop();
    }

    const runtime::Value& State::top() const {
        return vm_.top();
    }

    const runtime::Value& State::get(Size index) const {
        return vm_.get_stack(index);
    }

    void State::set(Size index, runtime::Value value) {
        vm_.set_stack(index, std::move(value));
    }

    runtime::Value State::get_global(const String& name) const {
        return vm_.get_global(name);
    }

    void State::set_global(const String& name, runtime::Value value) {
        logger()->debug("Setting global variable: {}", name);
        vm_.set_global(name, std::move(value));
    }

    bool State::has_global(const String& name) const {
        // Check if global exists by getting it and checking if it's nil
        auto value = vm_.get_global(name);
        return !value.is_nil();
    }

    void State::clear_globals() {
        logger()->info("Clearing all global variables");
        // VM reset will clear globals, but we need a more targeted approach
        // For now, we'll reset the entire VM state
        vm_.reset();
        initialize_globals();
    }

    runtime::VMState State::vm_state() const noexcept {
        return vm_.state();
    }

    void State::reset() {
        logger()->info("Resetting state");
        vm_.reset();
        initialize_globals();
    }

    void State::initialize_globals() {
        logger()->debug("Initializing global environment");

        // Setup basic global variables
        set_global("_VERSION", runtime::Value("RangeLua 0.1.0"));

        // Setup standard library
        setup_standard_library();

        logger()->debug("Global environment initialized");
    }

    void State::setup_standard_library() {
        logger()->debug("Setting up standard library");

        // Register basic library functions directly using set_global
        set_global("print", runtime::value_factory::function(stdlib::basic::print));
        set_global("type", runtime::value_factory::function(stdlib::basic::type));

        logger()->debug("Basic library functions registered");
        logger()->debug("Standard library setup complete");
    }

}  // namespace rangelua::api
