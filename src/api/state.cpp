/**
 * @file state.cpp
 * @brief Enhanced State implementation with comprehensive API support
 * @version 0.2.0
 */

#include <rangelua/api/state.hpp>
#include <rangelua/backend/bytecode.hpp>
#include <rangelua/backend/codegen.hpp>
#include <rangelua/core/error.hpp>
#include <rangelua/frontend/lexer.hpp>
#include <rangelua/frontend/parser.hpp>
#include <rangelua/runtime/gc.hpp>
#include <rangelua/stdlib/basic.hpp>
#include <rangelua/stdlib/math.hpp>
#include <rangelua/stdlib/string.hpp>
#include <rangelua/stdlib/table.hpp>
#include <rangelua/utils/logger.hpp>

#include <fstream>

namespace rangelua::api {

    // Initialize static logger
    namespace {
        auto& logger() {
            static auto log = utils::Logger::create_logger("api");
            return log;
        }
    }  // namespace

    State::State() : vm_(std::make_unique<runtime::VirtualMachine>()) {
        logger()->info("Initializing RangeLua state");

        // Initialize global environment
        initialize_globals();

        logger()->debug("State initialization complete");
    }

    State::State(const StateConfig& config)
        : vm_(std::make_unique<runtime::VirtualMachine>(config.vm_config)), config_(config) {
        logger()->info("Initializing RangeLua state with custom configuration");

        // Initialize global environment
        initialize_globals();

        logger()->debug("State initialization complete with config");
    }

    State::~State() {
        logger()->debug("Destroying RangeLua state");
        cleanup();

        // Force cleanup of thread-local GC to prevent memory leaks
        // This is crucial to run finalizers for any remaining objects.
        runtime::cleanupThreadLocalGC();

        logger()->debug("State destruction complete");
    }

    Result<std::vector<runtime::Value>> State::execute(StringView code, String name) {
        logger()->debug("Executing code: {} ({})", name, code.size());

        try {
            // Lexical analysis
            frontend::Lexer lexer(code, std::move(name));

            // Syntax analysis
            frontend::Parser parser(lexer);
            auto ast_result = parser.parse();
            if (std::holds_alternative<ErrorCode>(ast_result)) {
                auto error = std::get<ErrorCode>(ast_result);
                logger()->error("Parse error: {}", error_code_to_string(error));
                return error;
            }

            // Code generation
            backend::BytecodeEmitter emitter;
            backend::CodeGenerator codegen(emitter);
            auto codegen_result = codegen.generate(*std::get<frontend::ProgramPtr>(ast_result));
            if (std::holds_alternative<ErrorCode>(codegen_result)) {
                auto error = std::get<ErrorCode>(codegen_result);
                logger()->error("Codegen error: {}", error_code_to_string(error));
                return error;
            }

            // Get generated bytecode
            auto function = emitter.get_function();

            // Disassemble the function for debugging
            logger()->debug("Generated bytecode:\n{}",
                            backend::Disassembler::disassemble_function(function));

            // Execute
            logger()->debug("Executing bytecode function: {}", function.name);
            auto result = vm_->execute(function);

            if (is_success(result)) {
                logger()->debug("Execution completed successfully");
            } else {
                logger()->error("Execution failed: {}", error_code_to_string(get_error(result)));
            }

            return result;

        } catch (const Exception& e) {
            logger()->error("Exception during execution: {}", e.what());
            return e.code();
        } catch (const std::exception& e) {
            logger()->error("Standard exception during execution: {}", e.what());
            return ErrorCode::RUNTIME_ERROR;
        } catch (...) {
            logger()->error("Unknown exception during execution");
            return ErrorCode::UNKNOWN_ERROR;
        }
    }

    Result<std::vector<runtime::Value>> State::execute_file(const String& filename) {
        logger()->info("Executing file: {}", filename);

        std::ifstream file(filename);
        if (!file.is_open()) {
            logger()->error("Failed to open file: {}", filename);
            return ErrorCode::IO_ERROR;
        }

        std::string content((std::istreambuf_iterator<char>(file)),
                            std::istreambuf_iterator<char>());

        logger()->debug("File loaded, size: {} bytes", content.size());
        return execute(content, filename);
    }

    Size State::stack_size() const noexcept {
        return vm_->stack_size();
    }

    void State::push(runtime::Value value) {
        vm_->push(std::move(value));
    }

    runtime::Value State::pop() {
        return vm_->pop();
    }

    const runtime::Value& State::top() const {
        return vm_->top();
    }

    const runtime::Value& State::get(Size index) const {
        return vm_->get_stack(index);
    }

    void State::set(Size index, runtime::Value value) {
        vm_->set_stack(index, std::move(value));
    }

    runtime::Value State::get_global(const String& name) const {
        return vm_->get_global(name);
    }

    void State::set_global(const String& name, runtime::Value value) {
        logger()->debug("Setting global variable: {}", name);
        vm_->set_global(name, std::move(value));
    }

    bool State::has_global(const String& name) const {
        // Check if global exists by getting it and checking if it's nil
        auto value = vm_->get_global(name);
        return !value.is_nil();
    }

    void State::clear_globals() {
        logger()->info("Clearing all global variables");
        // VM reset will clear globals, but we need a more targeted approach
        // For now, we'll reset the entire VM state
        vm_->reset();
        initialize_globals();
    }

    runtime::VMState State::vm_state() const noexcept {
        return vm_->state();
    }

    void State::reset() {
        logger()->info("Resetting state");
        vm_->reset();
        initialize_globals();
    }

    void State::initialize_globals() {
        logger()->debug("Initializing global environment");

        // Setup basic global variables
        set_global("_VERSION", runtime::Value("RangeLua 0.1.0"));

        // Set up _G to point to the global table itself (Lua convention)
        // This creates a self-reference in the global table
        auto global_table = vm_->get_global_table();
        if (global_table) {
            set_global("_G", runtime::Value(global_table));
            logger()->debug("_G self-reference established");
        }

        // Setup standard library
        setup_standard_library();

        logger()->debug("Global environment initialized");
    }

    void State::setup_standard_library() {
        logger()->debug("Setting up standard library");

        // Register standard library modules
        auto global_table = vm_->get_global_table();
        if (global_table) {
            stdlib::basic::register_functions(this, global_table);
            logger()->debug("Basic library registered");

            stdlib::string::register_functions(this, global_table);
            logger()->debug("String library registered");

            stdlib::math::register_functions(this, global_table);
            logger()->debug("Math library registered");

            stdlib::table::register_functions(this, global_table);
            logger()->debug("Table library registered");
        }

        logger()->debug("Standard library setup complete");
    }

    void State::cleanup() {
        logger()->debug("Starting state cleanup");

        // Step 1: Break circular references in global table
        // Remove _G self-reference to break the cycle
        auto global_table = vm_->get_global_table();
        if (global_table) {
            logger()->debug("Breaking _G circular reference");
            runtime::Value key("_G");
            global_table->remove(key);
        }

        // Step 2: Clear all global variables to release references
        logger()->debug("Clearing global variables");
        if (global_table) {
            // Clear standard library functions and tables
            global_table->remove(runtime::Value("print"));
            global_table->remove(runtime::Value("type"));
            global_table->remove(runtime::Value("_VERSION"));
            global_table->remove(runtime::Value("math"));
            global_table->remove(runtime::Value("string"));
            global_table->remove(runtime::Value("table"));

            // Clear any remaining entries by iterating and removing
            // Since runtime::Table doesn't have clear(), we'll iterate and remove
            std::vector<runtime::Value> keys_to_remove;
            for (const auto& [key, value] : *global_table) {
                keys_to_remove.push_back(key);
            }
            for (const auto& key : keys_to_remove) {
                global_table->remove(key);
            }
        }

        // Step 3: Reset VM state to clean up environment and registry
        logger()->debug("Resetting VM state");
        vm_->reset();

        logger()->debug("State cleanup completed");
    }

    // IVMContext implementation
    runtime::Value& State::stack_at(Register reg) {
        return vm_->stack_at(reg);
    }

    const runtime::Value& State::stack_at(Register reg) const {
        return vm_->stack_at(reg);
    }

    Size State::instruction_pointer() const noexcept {
        return vm_->instruction_pointer();
    }

    void State::set_instruction_pointer(Size ip) noexcept {
        vm_->set_instruction_pointer(ip);
    }

    void State::adjust_instruction_pointer(std::int32_t offset) noexcept {
        vm_->adjust_instruction_pointer(offset);
    }

    const backend::BytecodeFunction* State::current_function() const noexcept {
        return vm_->current_function();
    }

    Size State::call_depth() const noexcept {
        return vm_->call_depth();
    }

    runtime::Value State::get_constant(std::uint16_t index) const {
        return vm_->get_constant(index);
    }

    Status State::call_function(const runtime::Value& function,
                                const std::vector<runtime::Value>& args,
                                std::vector<runtime::Value>& results) {
        return vm_->call_function(function, args, results);
    }

    Result<std::vector<runtime::Value>> State::pcall(const runtime::Value& function,
                                                     const std::vector<runtime::Value>& args) {
        return vm_->pcall(function, args);
    }

    Result<std::vector<runtime::Value>> State::xpcall(const runtime::Value& function,
                                                      const runtime::Value& msgh,
                                                      const std::vector<runtime::Value>& args) {
        return vm_->xpcall(function, msgh, args);
    }

    Status State::setup_call_frame(const backend::BytecodeFunction& function, Size arg_count) {
        return vm_->setup_call_frame(function, arg_count);
    }

    Status State::return_from_function(Size result_count) {
        return vm_->return_from_function(result_count);
    }

    void State::set_error(ErrorCode code) {
        vm_->set_error(code);
    }

void State::set_runtime_error(const String& message) {
        vm_->set_runtime_error(message);
    }
    void State::trigger_runtime_error(const String& message) {
        vm_->trigger_runtime_error(message);
    }

    runtime::RuntimeMemoryManager& State::memory_manager() noexcept {
        return vm_->memory_manager();
    }

    runtime::Value State::get_upvalue(UpvalueIndex index) const {
        return vm_->get_upvalue(index);
    }

    void State::set_upvalue(UpvalueIndex index, const runtime::Value& value) {
        vm_->set_upvalue(index, value);
    }

}  // namespace rangelua::api
