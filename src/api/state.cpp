/**
 * @file state.cpp
 * @brief Enhanced State implementation with comprehensive API support
 * @version 0.1.0
 */

#include <rangelua/api/state.hpp>
#include <rangelua/backend/bytecode.hpp>
#include <rangelua/backend/codegen.hpp>
#include <rangelua/core/error.hpp>
#include <rangelua/frontend/lexer.hpp>
#include <rangelua/frontend/parser.hpp>
#include <rangelua/stdlib/basic.hpp>
#include <rangelua/stdlib/string.hpp>
#include <rangelua/stdlib/math.hpp>
#include <rangelua/stdlib/table.hpp>
#include <rangelua/utils/logger.hpp>

#include <fstream>

namespace rangelua::api {

    // Initialize static logger
    namespace {
        auto& logger() {
            static auto log = utils::Logger::create_logger("api");
            return log;
        }
    }  // namespace

    State::State() : vm_() {
        logger()->info("Initializing RangeLua state");

        // Initialize global environment
        initialize_globals();

        logger()->debug("State initialization complete");
    }

    State::State(const StateConfig& config) : vm_(config.vm_config), config_(config) {
        logger()->info("Initializing RangeLua state with custom configuration");

        // Initialize global environment
        initialize_globals();

        logger()->debug("State initialization complete with config");
    }

    State::~State() {
        logger()->debug("Destroying RangeLua state");
        cleanup();
        logger()->debug("State destruction complete");
    }

    Result<std::vector<runtime::Value>> State::execute(StringView code, String name) {
        logger()->debug("Executing code: {} ({})", name, code.size());

        try {
            // Lexical analysis
            frontend::Lexer lexer(code, std::move(name));

            // Syntax analysis
            frontend::Parser parser(lexer);
            auto ast_result = parser.parse();
            if (std::holds_alternative<ErrorCode>(ast_result)) {
                auto error = std::get<ErrorCode>(ast_result);
                logger()->error("Parse error: {}", error_code_to_string(error));
                return error;
            }

            // Code generation
            backend::BytecodeEmitter emitter;
            backend::CodeGenerator codegen(emitter);
            auto codegen_result = codegen.generate(*std::get<frontend::ProgramPtr>(ast_result));
            if (std::holds_alternative<ErrorCode>(codegen_result)) {
                auto error = std::get<ErrorCode>(codegen_result);
                logger()->error("Codegen error: {}", error_code_to_string(error));
                return error;
            }

            // Get generated bytecode
            auto function = emitter.get_function();

            // Disassemble the function for debugging
            logger()->debug("Generated bytecode:\n{}",
                            backend::Disassembler::disassemble_function(function));

            // Execute
            logger()->debug("Executing bytecode function: {}", function.name);
            auto result = vm_.execute(function);

            if (is_success(result)) {
                logger()->debug("Execution completed successfully");
            } else {
                logger()->error("Execution failed: {}", error_code_to_string(get_error(result)));
            }

            return result;

        } catch (const Exception& e) {
            logger()->error("Exception during execution: {}", e.what());
            return e.code();
        } catch (const std::exception& e) {
            logger()->error("Standard exception during execution: {}", e.what());
            return ErrorCode::RUNTIME_ERROR;
        } catch (...) {
            logger()->error("Unknown exception during execution");
            return ErrorCode::UNKNOWN_ERROR;
        }
    }

    Result<std::vector<runtime::Value>> State::execute_file(const String& filename) {
        logger()->info("Executing file: {}", filename);

        std::ifstream file(filename);
        if (!file.is_open()) {
            logger()->error("Failed to open file: {}", filename);
            return ErrorCode::IO_ERROR;
        }

        std::string content((std::istreambuf_iterator<char>(file)),
                            std::istreambuf_iterator<char>());

        logger()->debug("File loaded, size: {} bytes", content.size());
        return execute(content, filename);
    }

    Size State::stack_size() const noexcept {
        return vm_.stack_size();
    }

    void State::push(runtime::Value value) {
        vm_.push(std::move(value));
    }

    runtime::Value State::pop() {
        return vm_.pop();
    }

    const runtime::Value& State::top() const {
        return vm_.top();
    }

    const runtime::Value& State::get(Size index) const {
        return vm_.get_stack(index);
    }

    void State::set(Size index, runtime::Value value) {
        vm_.set_stack(index, std::move(value));
    }

    runtime::Value State::get_global(const String& name) const {
        return vm_.get_global(name);
    }

    void State::set_global(const String& name, runtime::Value value) {
        logger()->debug("Setting global variable: {}", name);
        vm_.set_global(name, std::move(value));
    }

    bool State::has_global(const String& name) const {
        // Check if global exists by getting it and checking if it's nil
        auto value = vm_.get_global(name);
        return !value.is_nil();
    }

    void State::clear_globals() {
        logger()->info("Clearing all global variables");
        // VM reset will clear globals, but we need a more targeted approach
        // For now, we'll reset the entire VM state
        vm_.reset();
        initialize_globals();
    }

    runtime::VMState State::vm_state() const noexcept {
        return vm_.state();
    }

    void State::reset() {
        logger()->info("Resetting state");
        vm_.reset();
        initialize_globals();
    }

    void State::initialize_globals() {
        logger()->debug("Initializing global environment");

        // Setup basic global variables
        set_global("_VERSION", runtime::Value("RangeLua 0.1.0"));

        // Set up _G to point to the global table itself (Lua convention)
        // This creates a self-reference in the global table
        auto global_table = vm_.get_global_table();
        if (global_table) {
            set_global("_G", runtime::Value(global_table));
            logger()->debug("_G self-reference established");
        }

        // Setup standard library
        setup_standard_library();

        logger()->debug("Global environment initialized");
    }

    void State::setup_standard_library() {
        logger()->debug("Setting up standard library");

        // Register basic library functions directly using set_global
        set_global("print", runtime::value_factory::function(stdlib::basic::print));
        set_global("type", runtime::value_factory::function(stdlib::basic::type));
        set_global("ipairs", runtime::value_factory::function(stdlib::basic::ipairs));
        set_global("pairs", runtime::value_factory::function(stdlib::basic::pairs));
        set_global("next", runtime::value_factory::function(stdlib::basic::next));
        set_global("tostring", runtime::value_factory::function(stdlib::basic::tostring));
        set_global("tonumber", runtime::value_factory::function(stdlib::basic::tonumber));
        set_global("getmetatable", runtime::value_factory::function(stdlib::basic::getmetatable));
        set_global("setmetatable", runtime::value_factory::function(stdlib::basic::setmetatable));
        set_global("rawget", runtime::value_factory::function(stdlib::basic::rawget));
        set_global("rawset", runtime::value_factory::function(stdlib::basic::rawset));
        set_global("rawequal", runtime::value_factory::function(stdlib::basic::rawequal));
        set_global("rawlen", runtime::value_factory::function(stdlib::basic::rawlen));
        set_global("select", runtime::value_factory::function(stdlib::basic::select));
        set_global("error", runtime::value_factory::function(stdlib::basic::error));
        set_global("assert", runtime::value_factory::function(stdlib::basic::assert_));

        logger()->debug("Basic library functions registered");

        // Register standard library modules
        auto global_table = vm_.get_global_table();
        if (global_table) {
            stdlib::string::register_functions(global_table);
            logger()->debug("String library registered");

            stdlib::math::register_functions(global_table);
            logger()->debug("Math library registered");

            stdlib::table::register_functions(global_table);
            logger()->debug("Table library registered");
        }

        logger()->debug("Standard library setup complete");
    }

    void State::cleanup() {
        logger()->debug("Starting state cleanup");

        // Step 1: Break circular references in global table
        // Remove _G self-reference to break the cycle
        auto global_table = vm_.get_global_table();
        if (global_table) {
            logger()->debug("Breaking _G circular reference");
            runtime::Value key("_G");
            global_table->remove(key);
        }

        // Step 2: Clear all global variables to release references
        logger()->debug("Clearing global variables");
        if (global_table) {
            // Clear standard library functions
            global_table->remove(runtime::Value("print"));
            global_table->remove(runtime::Value("type"));
            global_table->remove(runtime::Value("_VERSION"));
        }

        // Step 3: Reset VM state to clean up environment and registry
        logger()->debug("Resetting VM state");
        vm_.reset();

        // Step 4: Force garbage collection to clean up remaining objects
        logger()->debug("Triggering garbage collection");
        auto gc_result = runtime::getGarbageCollector();
        if (is_success(gc_result)) {
            [[maybe_unused]] auto* gc = get_value(gc_result);
            // Note: collect() is protected, so we'll rely on automatic cleanup
            // during object destruction and reference counting
            logger()->debug("Garbage collector available for cleanup");
        }

        logger()->debug("State cleanup completed");
    }

}  // namespace rangelua::api
